// Code generated by exporter. DO NOT EDIT.
package rule_model

import (
	"errors"

	"coin-server/common/values"
)

// struct
type EquipEntry struct {
	Id             values.Integer                    `mapstructure:"id" json:"id"`
	Group          values.Integer                    `mapstructure:"group" json:"group"`
	Entryweight    values.Integer                    `mapstructure:"entryweight" json:"entryweight"`
	Attr           values.Integer                    `mapstructure:"attr" json:"attr"`
	TextId         string                            `mapstructure:"text_id" json:"text_id"`
	Lowvalue       values.Integer                    `mapstructure:"lowvalue" json:"lowvalue"`
	Maxvalue       values.Integer                    `mapstructure:"maxvalue" json:"maxvalue"`
	Qualitysection map[values.Integer]values.Integer `mapstructure:"qualitysection" json:"qualitysection"`
	QualityPer     map[values.Integer]values.Integer `mapstructure:"quality_per" json:"quality_per"`
	Skillquality   map[values.Integer]values.Integer `mapstructure:"skillquality" json:"skillquality"`
	Qualityweight  map[values.Integer]values.Integer `mapstructure:"qualityweight" json:"qualityweight"`
	SkillLv        map[values.Integer]values.Integer `mapstructure:"skill_lv" json:"skill_lv"`
	SkillId        []values.Integer                  `mapstructure:"skill_id" json:"skill_id"`
}

// parse func
func ParseEquipEntry(data *Data) {
	if err := data.UnmarshalKey("equip_entry", &h.equipEntry); err != nil {
		panic(errors.New("parse table EquipEntry err:\n" + err.Error()))
	}
	for i, el := range h.equipEntry {
		h.equipEntryMap[el.Id] = i
	}
}

func (i *EquipEntry) Len() int {
	return len(h.equipEntry)
}

func (i *EquipEntry) List() []EquipEntry {
	return h.equipEntry
}

func (i *EquipEntry) GetEquipEntryById(id values.Integer) (*EquipEntry, bool) {
	index, ok := h.equipEntryMap[id]
	if !ok {
		return nil, false
	}
	return &h.equipEntry[index], true
}
