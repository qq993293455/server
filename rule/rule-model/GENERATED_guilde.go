// Code generated by exporter. DO NOT EDIT.
package rule_model

import (
	"errors"

	"coin-server/common/values"
)

// struct
type Guilde struct {
	Id           values.Integer `mapstructure:"id" json:"id"`
	GuideTyp     values.Integer `mapstructure:"guide_typ" json:"guide_typ"`
	NextGuideId  values.Integer `mapstructure:"next_guide_id" json:"next_guide_id"`
	FrontGuideId values.Integer `mapstructure:"front_guide_id" json:"front_guide_id"`
	PerformType  values.Integer `mapstructure:"perform_type" json:"perform_type"`
	IsSkip       values.Integer `mapstructure:"is_skip" json:"is_skip"`
	Delay        values.Integer `mapstructure:"delay" json:"delay"`
	RecordPoint  string         `mapstructure:"record_point" json:"record_point"`
	Audio        string         `mapstructure:"audio" json:"audio"`
	TaskContent  string         `mapstructure:"task_content" json:"task_content"`
	IsRestore    values.Integer `mapstructure:"is_restore" json:"is_restore"`
	Drop         string         `mapstructure:"drop" json:"drop"`
	AssetName    []string       `mapstructure:"asset_name" json:"asset_name"`
	Val01        []string       `mapstructure:"val01" json:"val01"`
	Val02        []string       `mapstructure:"val02" json:"val02"`
	Val03        []string       `mapstructure:"val03" json:"val03"`
	Val04        []string       `mapstructure:"val04" json:"val04"`
}

// parse func
func ParseGuilde(data *Data) {
	if err := data.UnmarshalKey("guilde", &h.guilde); err != nil {
		panic(errors.New("parse table Guilde err:\n" + err.Error()))
	}
	for i, el := range h.guilde {
		h.guildeMap[el.Id] = i
	}
}

func (i *Guilde) Len() int {
	return len(h.guilde)
}

func (i *Guilde) List() []Guilde {
	return h.guilde
}

func (i *Guilde) GetGuildeById(id values.Integer) (*Guilde, bool) {
	index, ok := h.guildeMap[id]
	if !ok {
		return nil, false
	}
	return &h.guilde[index], true
}
