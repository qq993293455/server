// Code generated by exporter. DO NOT EDIT.
package rule_model

import (
	"errors"

	"coin-server/common/values"
)

// struct
type Looptask struct {
	Id                values.Integer                    `mapstructure:"id" json:"id"`
	Name              string                            `mapstructure:"name" json:"name"`
	NameLanguage      values.Integer                    `mapstructure:"name_language" json:"name_language"`
	Icon              string                            `mapstructure:"icon" json:"icon"`
	Desc              string                            `mapstructure:"desc" json:"desc"`
	TaskTargetParam   []values.Integer                  `mapstructure:"task_target_param" json:"task_target_param"`
	UnlockCondition   []values.Integer                  `mapstructure:"unlock_condition" json:"unlock_condition"`
	Kind              values.Integer                    `mapstructure:"kind" json:"kind"`
	Reward            map[values.Integer]values.Integer `mapstructure:"reward" json:"reward"`
	RewardType        values.Integer                    `mapstructure:"reward_type" json:"reward_type"`
	ExtraData         string                            `mapstructure:"extra_data" json:"extra_data"`
	ExtraDataLanguage values.Integer                    `mapstructure:"extra_data_language" json:"extra_data_language"`
}

// parse func
func ParseLooptask(data *Data) {
	if err := data.UnmarshalKey("looptask", &h.looptask); err != nil {
		panic(errors.New("parse table Looptask err:\n" + err.Error()))
	}
	for i, el := range h.looptask {
		h.looptaskMap[el.Id] = i
	}
}

func (i *Looptask) Len() int {
	return len(h.looptask)
}

func (i *Looptask) List() []Looptask {
	return h.looptask
}

func (i *Looptask) GetLooptaskById(id values.Integer) (*Looptask, bool) {
	index, ok := h.looptaskMap[id]
	if !ok {
		return nil, false
	}
	return &h.looptask[index], true
}
