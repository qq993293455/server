// Code generated by exporter. DO NOT EDIT.
package rule_model

import (
	"errors"

	"coin-server/common/values"
)

// struct
type SkillLv struct {
	RoleSkillId         values.Integer                    `mapstructure:"role_skill_id" json:"role_skill_id"`
	Id                  values.Integer                    `mapstructure:"id" json:"id"`
	UnlockLv            values.Integer                    `mapstructure:"unlock_lv" json:"unlock_lv"`
	UnlockSkillLv       map[values.Integer]values.Integer `mapstructure:"unlock_skill_lv" json:"unlock_skill_lv"`
	TalentPreconditions map[values.Integer]values.Integer `mapstructure:"talent_preconditions" json:"talent_preconditions"`
	PowerNum            values.Integer                    `mapstructure:"power_num" json:"power_num"`
}

// parse func
func ParseSkillLv(data *Data) {
	if err := data.UnmarshalKey("skill_lv", &h.skillLv); err != nil {
		panic(errors.New("parse table SkillLv err:\n" + err.Error()))
	}
	for i, el := range h.skillLv {
		if _, ok := h.skillLvMap[el.RoleSkillId]; !ok {
			h.skillLvMap[el.RoleSkillId] = map[values.Integer]int{el.Id: i}
		} else {
			h.skillLvMap[el.RoleSkillId][el.Id] = i
		}
	}
}

func (i *SkillLv) Len() int {
	return len(h.skillLv)
}

func (i *SkillLv) List() []SkillLv {
	return h.skillLv
}

func (i *SkillLv) GetSkillLvById(parentId, id values.Integer) (*SkillLv, bool) {
	item, ok := h.skillLvMap[parentId]
	if !ok {
		return nil, false
	}
	index, ok := item[id]
	if !ok {
		return nil, false
	}
	return &h.skillLv[index], true
}
