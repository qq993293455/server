// Code generated by exporter. DO NOT EDIT.
package rule_model

import (
	"errors"

	"coin-server/common/values"
)

// struct
type RoguelikeDungeonRoom struct {
	RoguelikeDungeonId   values.Integer     `mapstructure:"roguelike_dungeon_id" json:"roguelike_dungeon_id"`
	Id                   values.Integer     `mapstructure:"id" json:"id"`
	RoomVictoryCondition values.Integer     `mapstructure:"room_victory_condition" json:"room_victory_condition"`
	RoomFailCondition    values.Integer     `mapstructure:"room_fail_condition" json:"room_fail_condition"`
	RoomTyp              values.Integer     `mapstructure:"room_typ" json:"room_typ"`
	Reward               [][]values.Integer `mapstructure:"reward" json:"reward"`
	RandomNum            values.Integer     `mapstructure:"random_num" json:"random_num"`
	RewardWeight         []values.Integer   `mapstructure:"reward_weight" json:"reward_weight"`
	MapSceneId           values.Integer     `mapstructure:"map_scene_id" json:"map_scene_id"`
}

// parse func
func ParseRoguelikeDungeonRoom(data *Data) {
	if err := data.UnmarshalKey("roguelike_dungeon_room", &h.roguelikeDungeonRoom); err != nil {
		panic(errors.New("parse table RoguelikeDungeonRoom err:\n" + err.Error()))
	}
	for i, el := range h.roguelikeDungeonRoom {
		if _, ok := h.roguelikeDungeonRoomMap[el.RoguelikeDungeonId]; !ok {
			h.roguelikeDungeonRoomMap[el.RoguelikeDungeonId] = map[values.Integer]int{el.Id: i}
		} else {
			h.roguelikeDungeonRoomMap[el.RoguelikeDungeonId][el.Id] = i
		}
	}
}

func (i *RoguelikeDungeonRoom) Len() int {
	return len(h.roguelikeDungeonRoom)
}

func (i *RoguelikeDungeonRoom) List() []RoguelikeDungeonRoom {
	return h.roguelikeDungeonRoom
}

func (i *RoguelikeDungeonRoom) GetRoguelikeDungeonRoomById(parentId, id values.Integer) (*RoguelikeDungeonRoom, bool) {
	item, ok := h.roguelikeDungeonRoomMap[parentId]
	if !ok {
		return nil, false
	}
	index, ok := item[id]
	if !ok {
		return nil, false
	}
	return &h.roguelikeDungeonRoom[index], true
}
